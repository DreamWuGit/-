PBFT 共识算法
全名 PBFT(Practical Byzantine Fault Tolerance,实用拜占庭容错算法)，PBFT是一个历久不衰的经典
诞生至今已逾20年
它的发明源于分散式系统中一个著名的共识难题：拜占庭将军问题 (Byzantine Generals Problem)。PBFT并不是一个针对全开放环境的共识协定—事实上在区块链出现之前，并未出现任何一个针对开放环境的拜占庭容错共识。
区块链的横空出世启发了研究人员再度审视PBFT这个经典。
PBFT具有一些与区块链截然不同的特性，这提供了改进区块链一些有用的思路，例如以PBFT为基础建立的权益证明(Proof-of-stake)模型。
接下来我们将简介PBFT的起源背景、共识运作、正确性证明，以及PBFT与区块链不同的特性。
人类自古以来便不断追求可以永续运作的系统。
一个永续的系统，首先要能够容错以避免因单一故障而停摆。
一个实现容错的直觉作法就是让系统具有一定程度的冗余  —让有多个具有相同组成与状态的个体同时运作，如此当故障发生时只需替换故障的个体便能保证系统继续运作，在分散式系统中，我们称这样的设计为状态机复制 (State Machine Replication)。
什么是状态机？
状态机是一个抽象的黑盒子，它具有初始状态，并且在收到输入后，能依据相应的转换函数而转换至新的状态
且转换的过程是决定性的(Deterministic) — 只要给定相同的初始状态及输入，必定会得到相同的输出。而由数个具有相同转换函数的状态机组成的系统即为状态机复制。
为什么需要共识？由于状态机具有决定性，为了使这些冗余的状态机具有一致的状态，每个状态机都必须依相同的顺序进行状态转换，因此每个状态机必须达成对转换顺序的共识，这些状态机组成一个网路，每个状态机都是网路中的节点，
节点与节点间仅能透过通讯交换讯息以达成共识。为什么共识这么难？
在只依赖通讯便想达成共识的情境下，会碰到一个难解的问题，这也是在共识协定中一个著名问题：拜占庭将军问题。一群拜占庭将军围攻一座城市，他们必须达成同时进攻或同时撤退的共识，且各将军只能透过信使将自己的决定通知其他人。
然而，这群将军中有叛徒，可能会发出相反的讯息干扰，或者只通知一部分的将军。在已知有叛徒存在的情况下，该如何达成正确的共识？
显然，状态机复制的共识问题可以被化约成拜占庭将军问题：· 节点就是将军
· 通讯就是信使
· 进攻/撤退的决策就是需达成共识的内容
· 将军/状态机的随机行为称为拜占庭错误(Byzantine Fault)
· 叛徒/敌对状态机存在的情形下仍能达成共识的特性便称为拜占庭容错(Byzantine Fault Tolerance)。正确的共识：安全性(Safety)与活跃性(Liveness)
一个正确、可用的共识协定必须确保拜占庭将军们一定会达成唯一的共识(安全性)，且共识一定会形成(活跃性)。
具备安全性与活跃性的共识一定可以达成吗？答案是不一定。根据FLP原理：在非同步的网路通讯及决定性的程序(Process)下，若出现任一个毁坏故障(Crash Fault)，则共识不可能同时具备安全性与活跃性。
那怎么办？有两种方法可以绕过FLP原理的限制：第一种方法是假设网路通讯是同步的—这就是PBFT所采用的方式；第二种方法是在共识协定中引入一些随机的因子，使整个协定变为非决定性的 (Non-deterministic)，这样做的优点是协定更强健，就算在非同步的网路通讯下依然可以运作，
例如Honey Badger BFT就是一个非同步且非决定性的共识。效能如何？

在PBFT出现前，曾出现许多不同的共识协定，但是效能都不够好，直到PBFT的出现改变了一切，由其命名中的P(Practical)便能看出端倪。效能如何？

在PBFT出现前，曾出现许多不同的共识协定，但是效能都不够好，直到PBFT的出现改变了一切，由其命名中的P(Practical)便能看出端倪。
